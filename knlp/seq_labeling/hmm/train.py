# !/usr/bin/python
# -*- coding:UTF-8 -*-
# -----------------------------------------------------------------------#
# File Name: train
# Author: Junyi Li
# Mail: 4ljy@163.com
# Created Time: 2021-03-18
# Description:
# -----------------------------------------------------------------------#
"""
针对hmm的训练和推理，要清晰的分为不同的步骤，分步骤进行实现
0 清晰定义好hmm需要的几个参数
1 完成基于训练数据的hmm相关参数的代码并且完成相关的编码实现
2 完成hmm的inference相关的代码

针对序列标注问题，什么是可见状态，什么是隐藏状态，转移概率，发射概率
分词，我们这样应对：
SBME
我 是 一个 大 好 人
S  S  BE  B M E
可见状态：几个汉字
隐藏状态：几个字母，标注结果
转移概率：就是隐藏状态互相之间的概率大小
发射概率：是从隐藏状态到可见状态概率大小
初始状态：

换句话说，在inference的时候：
输入是
我 是 一个 大 好 人
输出则是对应的每个字下的标签是什么
直观感受来说，我们可以假设，不同的汉字对应于不同的标签有不同的概率大小，这个可以通过统计得到，经过大量的统计之后，我们可以知道给定一个汉字，它所对应各种标记的概率大小
则此时我们可以知道P(X|我)，P(X|是)，P(X|一)，P(X|个)，P(X|大)，P(X|好)，P(X|人)的大小分别是多少，例如：
P(X|我)就有四个结果：(随便举例的)
P(S|我) = 0.4
P(M|我) = 0.2
P(B|我) = 0.3
P(E|我) = 0.1
最后我们可以将他们乘起来【P(X|我)，P(X|是)，P(X|一)，P(X|个)，P(X|大)，P(X|好)，P(X|人)】，得到一整句话下使用不同标记的概率大小，找到概率最大的那个即可。
这就是最直觉的基于统计的分词方法。
可是，我们后知后觉的想一想，是不是前一个字的标签对后一个字的标签应该是有一定暗示意义的。比如，如果前一个字是S那么后一个字就不应该出现E和M。
这就涉及到前一个状态对后一个状态的影响，所以我们提出一个转移概率，就有马尔可夫链，而对于一阶马尔可夫，就是假设每一个标签只和前一个标签有关。
Q：一个状态集合
A：转移概率几何
init_P：初始概率。很直观的理解就是第一个字是什么标签，是会有一个统计出来的概率值的。

可是，这个时候我们就发现，我们其实是不知道一个字背后的标签的，所以我们需要把这两个信息合起来考虑。
所以HMM就允许我们同时谈论观测事件（我们看到的words）和隐藏事件（例如pos tag），
我们考虑让他们作为我们概率模型的因果变量。一个HMM模型可以被定义如下：
Q：一个状态集合：隐藏状态和观测状态
A：转移概率集合：隐藏状态之间的转移概率
O：观测序列：输入的序列
B：发射概率，表示从隐藏状态到观测状态的概率
初始状态集合：很直观的理解就是第一个字是什么标签，是会有一个统计出来的概率值的。

以上的这几种信息都是可以从给定的训练数据集中获取到的。
一个个看一下：
状态集合：把所有的汉字记录下来，隐藏状态也是我们自己定义的标签
转移概率集合：我们可以从训练数据中获取相关的信息，P(T_n|T_n-1)，那么只要做个相应的统计就可以实现这个需求。
观测序列：这个是我们在inference的时候会使用到的信息
发射概率：这个要统计的就是给定标签下，各个不同的汉字的概率是多少
初始状态集合：所有的字都会有一个P(X|我)，P(X|是)，P(X|一)，P(X|个)，P(X|大)，P(X|好)，P(X|人)
从以上的分析看来，一个分词要做的就是对一对数据的统计代码。

好，最后我们得到的一个模型，存储了以上的信息
然后我们完成一个inference的代码，利用这个模型进行对新输入的观测序列的inference
"""


class Train:
    """
    这个类要实现对以下四个信息的获取：
    状态集合：把所有的汉字记录下来，隐藏状态也是我们自己定义的标签
    转移概率集合：我们可以从训练数据中获取相关的信息，P(T_n|T_n-1)，那么只要做个相应的统计就可以实现这个需求。
    发射概率：这个要统计的就是给定标签下，各个不同的汉字的概率是多少
    初始状态集合：所有的字都会有一个P(X|我)，P(X|是)，P(X|一)，P(X|个)，P(X|大)，P(X|好)，P(X|人)
    从以上的分析看来，一个分词要做的就是对一对数据的统计代码。

    这个信息是输入信息和上面四个不太一样
    观测序列：这个是我们在inference的时候会使用到的信息
    """

    def __init__(self):
        self.transition_pro = {}
        self.emitsion_pro = {}
